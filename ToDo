1.
Сейчас часто наблюдается стабилизация в бинарном состоянии, когда несколько нейронов переключаются между двумя значениями сильно непохожими друг на друга, но все четные очень близки и все нечетные тоже.
Реализовать N.pre_out (значение нейрона за ход до этого) и сравнение pre_delta, т.е. дельта текущего значения и pre_out. Если эта дельта не велика, то не выводить ничего.

!!! Done. Сравнение с предыдущим выводом очень сильно улучшило ситуацию. Бинарные зацикленности исправились и "стабилизируются" за пару проходов.


2.
Подумать над уменьшением лавинообразного роста сигналов.

             -> N0 <-
            |  / \   |
            \_N1  N2_/

В такой схеме из трех нейронов на каждый вывод N0 генерируется два входа в N0 (От N1 и N2), что сейчас должно привести к двум новым выводам N0, итд.

Пока видится одно решение: Входные сигналы должны только сохраняться в матрице вхродных сигналов, но не вызывать calc. А calc должен запускаться в отдельном потоке, проверять, есть ли изменения в матрице, и если есть, считать и делать вывод, если нет - засыапать на какие-то доли секунды. Тогда, сколько бы сигналов не прилетело в промежутке сна, они все будут обработаны за раз и сгенерят только один вывод.
У этого решения есть минусы: Нейрон становится синхронным. и хоть они друг от друга по прежнему асинхронны, но внутри себя он по сути становится синхронным. При этом его работа очевидно замедляется, т.к. он будет реагировать не по ситуации, а ровно столько раз в секунду, сколько умещается в ней слипов. Кроме того, В случае "отдыха" нейрона, у нас постоянно будет поток, который будет 100-1000 раз в секунду просыпаться и проверять, не обновилась ли матрица. И так в каждом нейроне. Жалко.
В то же время, то что сделано в п.1 вроде бы несколько улучшает ситуацию, т.к. даже вот эти лавинообразные случаи в итоге не приводят к зацикливанию, а угасают, т.к. нейрон перестает меняться. Так что, может быть и забить можно на эту лавинообразность.


========================================================================

Для определения проблемных мест, где должны быть, но не используются мьютексы.
go build --race
иди
go run --race

========================================================================

Сергей предлагает не использовать множественные селекты, а ставить у канала емкость, и все синапсы пихать в один канал. А в структуре передаваемых данных передавать и метку источника.

Также, можно вообще не использовать селект.

https://github.com/0xef53/rigel/blob/master/rigel.go
for p := range chan {
    do_something(p)
}
вот эта конструкция будет обрабатывать сразу все пришедшие данные в канал. 
И если данные перестали идти, она будет дать, пока канал не закрыт. Если данные полетят снова, она начнет снова их обрабатывать.

Надо поэкспериментировать. Это вполне может быть решением для проблемы 2.
