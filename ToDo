1.
Сейчас часто наблюдается стабилизация в бинарном состоянии, когда несколько нейронов переключаются между двумя значениями сильно непохожими друг на друга, но все четные очень близки и все нечетные тоже.
Реализовать N.pre_out (значение нейрона за ход до этого) и сравнение pre_delta, т.е. дельта текущего значения и pre_out. Если эта дельта не велика, то не выводить ничего.

!!! Done. Сравнение с предыдущим выводом очень сильно улучшило ситуацию. Бинарные зацикленности исправились и "стабилизируются" за пару проходов.


2.
Подумать над уменьшением лавинообразного роста сигналов.

             -> N0 <-
            |  / \   |
            \_N1  N2_/

В такой схеме из трех нейронов на каждый вывод N0 генерируется два входа в N0 (От N1 и N2), что сейчас должно привести к двум новым выводам N0, итд.

Пока видится одно решение: Входные сигналы должны только сохраняться в матрице вхродных сигналов, но не вызывать calc. А calc должен запускаться в отдельном потоке, проверять, есть ли изменения в матрице, и если есть, считать и делать вывод, если нет - засыапать на какие-то доли секунды. Тогда, сколько бы сигналов не прилетело в промежутке сна, они все будут обработаны за раз и сгенерят только один вывод.
У этого решения есть минусы: Нейрон становится синхронным. и хоть они друг от друга по прежнему асинхронны, но внутри себя он по сути становится синхронным. При этом его работа очевидно замедляется, т.к. он будет реагировать не по ситуации, а ровно столько раз в секунду, сколько умещается в ней слипов. Кроме того, В случае "отдыха" нейрона, у нас постоянно будет поток, который будет 100-1000 раз в секунду просыпаться и проверять, не обновилась ли матрица. И так в каждом нейроне. Жалко.
В то же время, то что сделано в п.1 вроде бы несколько улучшает ситуацию, т.к. даже вот эти лавинообразные случаи в итоге не приводят к зацикливанию, а угасают, т.к. нейрон перестает меняться. Так что, может быть и забить можно на эту лавинообразность.
